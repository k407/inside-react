<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="favicon.ico">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/redux@latest/dist/redux.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-redux@8.0.1/dist/react-redux.min.js" crossorigin></script>
    <script src="https://unpkg.com/redux-thunk@2.1.0/dist/redux-thunk.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/jsx">
      const api = {
        get(url) {
          switch (url) {
            case '/items':
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  if (Math.random() > 0.25) {
                    resolve([
                      {
                        id: 1,
                        name: 'item_1',
                        price: 7,
                        favorite: true,
                      },
                      {
                        id: 2,
                        name: 'item_2',
                        price: 9,
                        favorite: false,
                      },
                      {
                        id: 3,
                        name: 'item_3',
                        price: 11,
                        favorite: false,
                      },
                    ]);
                  } else {
                    reject(new Error('Connection error'));
                  }
                }, 1000);
              });
            default:
              throw new Error('404');
          }
        },
        post(url) {
          if (/^\/items\/(\d+)\/favorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve({});
              }, 500);
            });
          }
          if (/^\/items\/(\d+)\/unfavorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve({});
              }, 500);
            });
          }
          throw new Error('Unknown address');
        },
      };

      const stream = {
        subscribe(channel, listener) {
          const match = /price-(\d+)/.exec(channel);

          if (match) {
            const interval = setInterval(() => {
              listener({
                id: parseInt(match[1]),
                price: Math.floor(Math.random() * 10 + 1),
              });
            }, 400);
            return () => clearInterval(interval);
          }
        },
      };

      // ##########################################################################

      const productsInitialState = {
        items: [],
        loading: false,
        loaded: false,
        error: null,
      };

      const ITEMS_LOADING_PENDING = 'ITEMS_LOADING_PENDING';
      const ITEMS_LOADING_SUCCESS = 'ITEMS_LOADING_SUCCESS';
      const ITEMS_LOADING_ERROR = 'ITEMS_LOADING_ERROR';
      const CHANGE_ITEM_PRICE = 'CHANGE_ITEM_PRICE';
      const FAVORITE_ITEM = 'FAVORITE_ITEM';
      const UNFAVORITE_ITEM = 'UNFAVORITE_ITEM';

      function productsReducer(state = productsInitialState, action) {
        switch (action.type) {
          case ITEMS_LOADING_PENDING:
            return {
              ...state,
              items: [],
              loading: true,
              loaded: false,
              error: null,
            };
          case ITEMS_LOADING_SUCCESS:
            return {
              ...state,
              items: action.items,
              loading: false,
              loaded: true,
              error: null,
            };
          case ITEMS_LOADING_ERROR:
            return {
              ...state,
              items: [],
              loading: false,
              loaded: false,
              error: action.error,
            };
          case CHANGE_ITEM_PRICE:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    price: action.price,
                  };
                }
                return item;
              }),
            };
          case FAVORITE_ITEM:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    favorite: true,
                  };
                }
                return item;
              }),
            };
          case UNFAVORITE_ITEM:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    favorite: false,
                  };
                }
                return item;
              }),
            };
          default:
            return state;
        }
      }

      // ##########################################################################

      function ItemsLoadingPending() {
        return {
          type: ITEMS_LOADING_PENDING,
        };
      }

      function ItemsLoadingSuccess(items) {
        return {
          type: ITEMS_LOADING_SUCCESS,
          items,
        };
      }

      function ItemsLoadingError(error) {
        return {
          type: ITEMS_LOADING_ERROR,
          error,
        };
      }

      function loadItemsAsync() {
        return (dispatch, getState, { api }) => {
          dispatch(ItemsLoadingPending());
          api
            .get('/items')
            .then((items) => dispatch(ItemsLoadingSuccess(items)))
            .catch((error) => dispatch(ItemsLoadingError(error.message)));
        };
      }

      function changeItemPrice(id, price) {
        return {
          type: CHANGE_ITEM_PRICE,
          id,
          price,
        };
      }

      function subscribeToItemPrice(id) {
        return (dispatch, getState, { stream }) => {
          return stream.subscribe(`price-${id}`, (data) => {
            dispatch(changeItemPrice(data.id, data.price));
          });
        };
      }

      function favoriteItem(id) {
        return {
          type: FAVORITE_ITEM,
          id,
        };
      }

      function favoriteItemAsync(id) {
        return (dispatch, getState, { api }) => {
          return api.post(`/items/${id}/favorite`).then(() => {
            dispatch(favoriteItem(id));
          });
        };
      }

      function unfavoriteItem(id) {
        return {
          type: UNFAVORITE_ITEM,
          id,
        };
      }

      function unfavoriteItemAsync(id) {
        return (dispatch, getState, { api }) => {
          return api.post(`/items/${id}/unfavorite`).then(() => {
            dispatch(unfavoriteItem(id));
          });
        };
      }

      // ##########################################################################

      const thunk = ReduxThunk.default;

      const store = Redux.createStore(
        Redux.combineReducers({ products: productsReducer }),
        Redux.applyMiddleware(thunk.withExtraArgument({ api, stream }))
      );

      // ##########################################################################

      function Router() {
        const [location, setLocation] = React.useState('a');

        const navigate = (location) => {
          setLocation(location);
        };

        return (
          <RouterContext.Provider value={{ location, navigate }}>
            <ul>
              <li>
                <Link to="a" navigate={navigate}>
                  a
                </Link>
              </li>
              <li>
                <Link to="b" navigate={navigate}>
                  b
                </Link>
              </li>
              <li>
                <Link to="c" navigate={navigate}>
                  c
                </Link>
              </li>
            </ul>
            <div>
              <Route path="a" location={location}>
                <p>Content A</p>
              </Route>
              <Route path="b" location={location}>
                <p>Content B</p>
              </Route>
              <Route path="c" location={location}>
                <p>Content C</p>
              </Route>
            </div>
          </RouterContext.Provider>
        );
      }

      const RouterContext = React.createContext();

      function Link({ to, children, ...options }) {
        return (
          <RouterContext.Consumer>
            {(value) => {
              const onClick = (event) => {
                event.preventDefault();
                value.navigate(to);
              };
              return (
                <a href="" onClick={onClick} {...options}>
                  {children}
                </a>
              );
            }}
          </RouterContext.Consumer>
        );
      }

      function Route({ path, children }) {
        return (
          <RouterContext.Consumer>
            {(value) => {
              if (value.location === path) {
                return children;
              }
              return null;
            }}
          </RouterContext.Consumer>
        );
      }

      // ##########################################################################

      function App() {
        return (
          <div className="wrapper">
            <Router />
            <Header />
            <ItemsContainerConnected />
          </div>
        );
      }

      function Header() {
        return (
          <header className="header">
            <Logo />
            <ClockContainer />
          </header>
        );
      }

      function Logo() {
        return <img className="logo" src="images/logo.png" alt="" />;
      }

      function ClockContainer() {
        const [time, setTime] = React.useState(new Date());

        React.useEffect(() => {
          const interval = setInterval(() => {
            setTime(new Date());
          }, 1000);

          return () => clearInterval(interval);
        }, [setTime]);

        return <Clock time={time} />;
      }

      function Clock({ time }) {
        const isDay = time.getHours() >= 7 && time.getHours() <= 21;

        return (
          <div className="clock">
            <span className="value">{time.toLocaleTimeString()}</span>
            <img className="icon" src={isDay ? 'images/sun.png' : 'images/moon.png'} alt="" />
          </div>
        );
      }

      function LoadingContainer() {
        const [placeholders, setPlaceholders] = React.useState([
          {
            id: 1,
            tagName: 'p',
            className: 'placeholder_xsmall',
            innerText: '\u00A0',
          },
          {
            id: 2,
            tagName: 'p',
            className: 'placeholder_large',
            innerText: '\u00A0',
          },
          {
            id: 3,
            tagName: 'p',
            className: 'placeholder_small',
            innerText: '\u00A0',
          },
          {
            id: 4,
            tagName: 'p',
            className: 'placeholder_medium',
            innerText: '\u00A0',
          },
        ]);

        return <Loading placeholders={placeholders} />;
      }

      function Loading({ placeholders }) {
        return (
          <div className="placeholder">
            {placeholders.map((placeholder) => (
              <Placeholder placeholder={placeholder} key={placeholder.id} />
            ))}
          </div>
        );
      }

      function Placeholder({ placeholder }) {
        return (
          <placeholder.tagName className={placeholder.className}>
            {placeholder.innerText}
          </placeholder.tagName>
        )
      }

      function AlertError({ message }) {
        return <div className="error">{message}</div>;
      }

      function ItemsContainer({ items, loading, loaded, error, load }) {
        React.useEffect(() => {
          if (!loaded && !loading && error === null) {
            load();
          }
        }, [loading, loaded, error]);

        if (error !== null) {
          return <AlertError message={error} />;
        }

        if (loading) {
          return <LoadingContainer />;
        }

        if (!loaded) {
          return null;
        }

        return <Items items={items} />;
      }

      const itemsContainerMapStateToProps = (state) => ({
        items: state.products.items,
        loading: state.products.loading,
        loaded: state.products.loaded,
        error: state.products.error,
      });

      const itemsContainerMapDispatchToProps = {
        load: loadItemsAsync,
      };

      const ItemsContainerConnected = ReactRedux.connect(
        itemsContainerMapStateToProps,
        itemsContainerMapDispatchToProps
      )(ItemsContainer);

      function Items({ items }) {
        return (
          <div className="items">
            {items.map((item) => (
              <ItemContainerConnected item={item} key={item.id} />
            ))}
          </div>
        );
      }

      function ItemContainer({ item, subscribe }) {
        React.useEffect(() => {
          return subscribe(item.id);
        }, [item.id]);

        return <ItemConnected item={item} />;
      }

      const itemContainerMapDispatchToProps = {
        subscribe: subscribeToItemPrice,
      };

      const ItemContainerConnected = ReactRedux.connect(null, itemContainerMapDispatchToProps)(ItemContainer);

      function Item({ item, favorite, unfavorite }) {
        return (
          <article className={'item' + (item.favorite ? ' item_favorite' : '')}>
            <h2 className="item_name">{item.name}</h2>
            <div className="item_price">{item.price}</div>
            <Favorite
              active={item.favorite}
              id={item.id}
              favorite={() => favorite(item.id)}
              unfavorite={() => unfavorite(item.id)}
            />
          </article>
        );
      }

      const itemMapDispatchToProps = {
        favorite: favoriteItemAsync,
        unfavorite: unfavoriteItemAsync,
      };

      const ItemConnected = ReactRedux.connect(null, itemMapDispatchToProps)(Item);

      function Favorite({ active, favorite, unfavorite }) {
        const [enabled, setEnabled] = React.useState(true);

        const onClickFavorite = () => {
          setEnabled(false);
          favorite()
            .then(() => setEnabled(true))
            .catch(() => setEnabled(true));
        };

        const onClickUnfavorite = () => {
          setEnabled(false);
          unfavorite()
            .then(() => setEnabled(true))
            .catch(() => setEnabled(true));
        };

        return active ? (
          <button type="button" onClick={onClickUnfavorite} className="unfavorite" disabled={!enabled}>
            <img className="favorite_icon" src="images/heart-sharp.png" alt="" /> Unfavorite
          </button>
        ) : (
          <button type="button" onClick={onClickFavorite} className="favorite" disabled={!enabled}>
            <img className="favorite_icon" src="images/heart-outline.png" alt="" /> Favorite
          </button>
        );
      }

      // ##########################################################################

      ReactDOM.render(
        <ReactRedux.Provider store={store}>
          <App />
        </ReactRedux.Provider>,
        document.querySelector('#app')
      );
    </script>
  </body>
</html>
