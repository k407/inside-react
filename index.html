<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="icon" href="favicon.ico">
    <title>Document</title>
    <link rel="stylesheet" href="css/main.css">
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/redux@latest/dist/redux.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-redux@8.0.1/dist/react-redux.min.js" crossorigin></script>
    <script src="https://unpkg.com/redux-thunk@2.1.0/dist/redux-thunk.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>
  </head>
  <body>
    <div id="app"></div>
    <script type="text/jsx">
      const api = {
        get(url) {
          switch (url) {
            case '/items':
              return new Promise((resolve, reject) => {
                setTimeout(() => {
                  if (Math.random() > 0.25) {
                    resolve([
                      {
                        id: 1,
                        name: 'item_1',
                        price: 7,
                        favorite: true,
                      },
                      {
                        id: 2,
                        name: 'item_2',
                        price: 9,
                        favorite: false,
                      },
                      {
                        id: 3,
                        name: 'item_3',
                        price: 11,
                        favorite: false,
                      },
                    ]);
                  } else {
                    reject(new Error('Connection error'));
                  }
                }, 1000);
              });
            default:
              throw new Error('404');
          }
        },
        post(url) {
          if (/^\/items\/(\d+)\/favorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve({});
              }, 500);
            });
          }
          if (/^\/items\/(\d+)\/unfavorite$/.exec(url)) {
            return new Promise((resolve) => {
              setTimeout(() => {
                resolve({});
              }, 500);
            });
          }
          throw new Error('Unknown address');
        },
      };

      const stream = {
        subscribe(channel, listener) {
          const match = /price-(\d+)/.exec(channel);

          if (match) {
            const interval = setInterval(() => {
              listener({
                id: parseInt(match[1]),
                price: Math.floor(Math.random() * 10 + 1),
              });
            }, 400);
            return () => clearInterval(interval);
          }
        },
      };

      const productsInitialState = {
        items: [],
        loading: false,
        loaded: false,
        error: null,
      };

      const ITEMS_LOADING_PENDING = 'ITEMS_LOADING_PENDING';
      const ITEMS_LOADING_SUCCESS = 'ITEMS_LOADING_SUCCESS';
      const ITEMS_LOADING_ERROR = 'ITEMS_LOADING_ERROR';
      const CHANGE_ITEM_PRICE = 'CHANGE_ITEM_PRICE';
      const FAVORITE_ITEM = 'FAVORITE_ITEM';
      const UNFAVORITE_ITEM = 'UNFAVORITE_ITEM';

      function productsReducer(state = productsInitialState, action) {
        switch (action.type) {
          case ITEMS_LOADING_PENDING:
            return {
              ...state,
              items: [],
              loading: true,
              loaded: false,
              error: null,
            };
          case ITEMS_LOADING_SUCCESS:
            return {
              ...state,
              items: action.items,
              loading: false,
              loaded: true,
              error: null,
            };
          case ITEMS_LOADING_ERROR:
            return {
              ...state,
              items: [],
              loading: false,
              loaded: false,
              error: action.error,
            };
          case CHANGE_ITEM_PRICE:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    price: action.price,
                  };
                }
                return item;
              }),
            };
          case FAVORITE_ITEM:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    favorite: true,
                  };
                }
                return item;
              }),
            };
          case UNFAVORITE_ITEM:
            return {
              ...state,
              items: state.items.map((item) => {
                if (item.id === action.id) {
                  return {
                    ...item,
                    favorite: false,
                  };
                }
                return item;
              }),
            };
          default:
            return state;
        }
      }

      function createLoadingPendingAction() {
        return {
          type: ITEMS_LOADING_PENDING,
        };
      }

      function createLoadingSuccessAction(items) {
        return {
          type: ITEMS_LOADING_SUCCESS,
          items,
        };
      }

      function createItemsLoadingErrorAction(error) {
        return {
          type: ITEMS_LOADING_ERROR,
          error,
        };
      }

      function createLoadItemsAsyncAction() {
        return (dispatch, getState, { api }) => {
          dispatch(createLoadingPendingAction());
          api
            .get('/items')
            .then((items) => dispatch(createLoadingSuccessAction(items)))
            .catch((error) => dispatch(createItemsLoadingErrorAction(error.message)));
        };
      }

      function createChangeItemPriceAction(id, price) {
        return {
          type: CHANGE_ITEM_PRICE,
          id,
          price,
        };
      }

      function createSubscribeToItemPriceAction(id) {
        return (dispatch, getState, { stream }) => {
          return stream.subscribe(`price-${id}`, (data) => {
            dispatch(createChangeItemPriceAction(data.id, data.price));
          });
        };
      }

      function createFavoriteItemAction(id) {
        return {
          type: FAVORITE_ITEM,
          id,
        };
      }

      function createFavoriteAsyncAction(id) {
        return (dispatch, getState, { api }) => {
          api.post(`/items/${id}/favorite`).then(() => {
            dispatch(createFavoriteItemAction(id));
          });
        };
      }

      function createUnfavoriteItemAction(id) {
        return {
          type: UNFAVORITE_ITEM,
          id,
        };
      }

      function createUnfavoriteAsyncAction(id) {
        return (dispatch, getState, { api }) => {
          api.post(`/items/${id}/unfavorite`).then(() => {
            dispatch(createUnfavoriteItemAction(id));
          });
        };
      }

      const loadingInitialState = {
        placeholders: [
          {
            id: 1,
            tagName: 'p',
            className: 'placeholder_xsmall',
            innerText: '\u00A0',
          },
          {
            id: 2,
            tagName: 'p',
            className: 'placeholder_large',
            innerText: '\u00A0',
          },
          {
            id: 3,
            tagName: 'p',
            className: 'placeholder_small',
            innerText: '\u00A0',
          },
          {
            id: 4,
            tagName: 'p',
            className: 'placeholder_medium',
            innerText: '\u00A0',
          },
        ],
      };

      function loadingReducer(state = loadingInitialState) {
        return state;
      }

      const thunk = ReduxThunk.default;

      const store = Redux.createStore(
        Redux.combineReducers({
          loading: loadingReducer,
          products: productsReducer,
        }),
        Redux.applyMiddleware(thunk.withExtraArgument({ api, stream }))
      );

      function App() {
        return (
          <div className="wrapper">
            <Header />
            <ItemsContainerConnected />
          </div>
        );
      }

      function Header() {
        return (
          <header className="header">
            <Logo />
            <ClockContainer />
          </header>
        );
      }

      function Logo() {
        return <img className="logo" src="images/logo.png" alt="" />;
      }

      function ClockContainer() {
        const [time, setTime] = React.useState(new Date());

        React.useEffect(() => {
          const interval = setInterval(() => {
            setTime(new Date());
          }, 1000);

          return () => clearInterval(interval);
        }, [setTime]);

        return <Clock time={time} />;
      }

      function Clock({ time }) {
        const isDay = time.getHours() >= 7 && time.getHours() <= 21;

        return (
          <div className="clock">
            <span className="value">{time.toLocaleTimeString()}</span>
            <img className="icon" src={isDay ? 'images/sun.png' : 'images/moon.png'} alt="" />
          </div>
        );
      }

      function Placeholder({ placeholder }) {
        return (
          <placeholder.tagName className={placeholder.className}>
            {placeholder.innerText}
          </placeholder.tagName>
        )
      }

      function Loading({ placeholders }) {
        return (
          <div className="placeholder">
            {placeholders.map((placeholder) => (
              <Placeholder placeholder={placeholder} key={placeholder.id} />
            ))}
          </div>
        );
      }

      function AlertError({ message }) {
        return <div className="error">{message}</div>;
      }

      const itemsContainerMapStateToProps = (state) => ({
        items: state.products.items,
        loading: state.products.loading,
        loaded: state.products.loaded,
        error: state.products.error,
        placeholders: state.loading.placeholders,
      });

      const itemsContainerMapDispatchToProps = {
        load: createLoadItemsAsyncAction,
      };

      const ItemsContainerConnected = ReactRedux.connect(
        itemsContainerMapStateToProps,
        itemsContainerMapDispatchToProps
      )(ItemsContainer);

      function ItemsContainer({ items, loading, loaded, error, load, placeholders }) {
        React.useEffect(() => {
          if (!loaded && !loading && error === null) {
            load();
          }
        }, [loaded, loading, error]);

        if (error !== null) {
          return <AlertError message={error} />
        }

        if (loading) {
          return <Loading placeholders={placeholders} />;
        }

        if (!loaded) {
          return null;
        }

        return <Items items={items} />;
      }

      function Items({ items }) {
        return (
          <div className="items">
            {items.map((item) => (
              <ItemContainerConnected item={item} key={item.id} />
            ))}
          </div>
        );
      }

      const itemContainerMapDispatchToProps = {
        subscribe: createSubscribeToItemPriceAction,
      };

      const ItemContainerConnected = ReactRedux.connect(null, itemContainerMapDispatchToProps)(ItemContainer);

      function ItemContainer({ item, subscribe }) {
        React.useEffect(() => {
          return subscribe(item.id);
        }, [item.id]);

        return <ItemConnected item={item} />;
      }

      const itemMapDispatchToProps = {
        favorite: createFavoriteAsyncAction,
        unfavorite: createUnfavoriteAsyncAction,
      };

      const ItemConnected = ReactRedux.connect(null, itemMapDispatchToProps)(Item);

      function Item({ item, subscribe, favorite, unfavorite }) {
        return (
          <article className={'item' + (item.favorite ? ' item_favorite' : '')}>
            <h2 className="item_name">{item.name}</h2>
            <div className="item_price">{item.price}</div>
            <Favorite
              active={item.favorite}
              id={item.id}
              favorite={() => favorite(item.id)}
              unfavorite={() => unfavorite(item.id)}
            />
          </article>
        );
      }

      function Favorite({ active, favorite, unfavorite }) {
        return active ? (
          <button type="button" className="unfavorite" onClick={unfavorite}>
            <img className="favorite_icon" src="images/heart-sharp.png" alt="" /> Unfavorite
          </button>
        ) : (
          <button type="button" className="favorite" onClick={favorite}>
            <img className="favorite_icon" src="images/heart-outline.png" alt="" /> Favorite
          </button>
        );
      }

      ReactDOM.render(
        <ReactRedux.Provider store={store}>
          <App />
        </ReactRedux.Provider>,
        document.querySelector('#app')
      );
    </script>
  </body>
</html>
